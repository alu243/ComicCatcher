@model ComicCatcherLib.ComicModels.ComicEntity

@{
    ViewBag.Title = "title";
    Layout = "_Layout";
}

<h2 class="center">@Model.Caption</h2>

<div id="app">
    <button style="font-size: 20px;" @@click="goBack()">上一頁</button>
    <br />
    <div v-for="chapter in state.chapters">
        <h2 style="text-align: center;">{{ chapter.currChapter.caption }}</h2>
        <div v-for="x in chapter.currChapter.pages" class="center sapce">
            <img :src="x.url" class="pageImg" alt="Snow" border="2" />
        </div>
        <hr />
    </div>
    <br />
    <div v-if="loading && !ending">讀取中...</div>
    <div v-if="ending">已經是最新的了</div>
    <button style="font-size: 20px;" @@click="goBack()">上一頁</button>
    
    <Observer v-if="state.chapters.length > 0 && !loading && !ending" @@intersect="intersected" />
</div>

@section Scripts {
    <script type="text/javascript">
        const { createApp, onMounted, onBeforeUnmount, reactive, ref } = Vue;
        const app = createApp({
            components: {
                Observer,
            },
            setup() {
                const state = reactive({
                    chapters: [],
                });
                const loading = ref(true);
                const ending = ref(false);

                const pathArray = window.location.pathname.split('/');
                const chapter = pathArray[pathArray.length - 1];
                const comic = pathArray[pathArray.length - 2];

                // 更新進度
                const updateFavoriteChapter = function(comic, chapter, chapterName){
                    fetch("/api/favoritechapter", {
                        method: "POST",
                        credentials: "same-origin", // 帶 cookie
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            "comic": comic,
                            "chapter": chapter,
                            "chapterName": chapterName
                        })
                    });
                }

                onMounted(async () => {
                    const response = await fetch(`/api/comic/${comic}/${chapter}`);
                    const chapterResponse = await response.json();
                    state.chapters.push(chapterResponse);

                    // 更新進度
                    updateFavoriteChapter(chapterResponse.comic, chapterResponse.chapter, chapterResponse.chapterName);

                    setTimeout(() => loading.value = false, 1000);
                });


                const goBack = function () {
                    const pathArray = window.location.pathname.split('/');
                    const chapter = pathArray[pathArray.length - 1];
                    const comic = pathArray[pathArray.length - 2];
                    location.href = `/comic/${comic}`;
                }

                const intersected = async function () {
                    console.log("Next~~~");
                    if (loading.value == true) return;
                    loading.value = true;
                    var lastChapter = state.chapters[state.chapters.length - 1];
                    const response = await fetch(`/api/comic/${lastChapter.comic}/${lastChapter.chapter}/next`);
                    var text = await response.text();
                    if (text == null || text == "") {
                        ending.value = true;
                        loading.value = false;
                        return;
                    }
                    const chapterResponse = await JSON.parse(text);

                    // 更新進度
                    updateFavoriteChapter(chapterResponse.comic, chapterResponse.chapter, chapterResponse.chapterName);

                    history.pushState(chapterResponse, '', `/comic/${chapterResponse.comic}/${chapterResponse.chapter}`);
                    state.chapters.push(chapterResponse);
                    //if (state.chapters.length > 3) state.chapters.shift();
                    loading.value = false;
                }

                return {
                    state,
                    goBack,
                    intersected,
                    loading,
                    ending
                }
            }
        });
        //app.component(Observer);
        app.mount('#app');
        console.log("start app", app);
    </script>
}
